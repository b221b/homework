                                                                    /* Задание_1.1 */
#include <iostream>
#include <string>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    // Конструктор класса
    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
    }

    // Методы получения значения полей
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }
};

int main() {
    // Создание экземпляра класса Goods
    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    // Проверка значений полей
    cout << "Наименование товара: " << item.getName() << endl;
    cout << "Дата оформления: " << item.getDate() << endl;
    cout << "Цена товара: " << item.getPrice() << endl;
    cout << "Количество единиц товара: " << item.getQuantity() << endl;
    cout << "Номер накладной: " << item.getInvoiceNumber() << endl;

    return 0;
}

                                                                       /* Задание_1.2 */
#include <iostream>
#include <string>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    // Конструктор по умолчанию
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        cout << "Вызван конструктор по умолчанию." << endl;
    }

    // Конструктор класса
    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        cout << "Вызван конструктор с параметрами." << endl;
    }

    // Деструктор
    ~Goods() {
        cout << "Вызван деструктор." << endl;
    }

    // Методы получения значения полей
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }
};

int main() {
    // Создание экземпляра класса Goods с параметрами
    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    // Проверка значений полей
    cout << "Наименование товара: " << item.getName() << endl;
    cout << "Дата оформления: " << item.getDate() << endl;
    cout << "Цена товара: " << item.getPrice() << endl;
    cout << "Количество единиц товара: " << item.getQuantity() << endl;
    cout << "Номер накладной: " << item.getInvoiceNumber() << endl;
    
    // Создание экземпляра класса Goods по умолчанию
    Goods defaultItem;

    // Проверка значений полей
    cout << "Наименование товара: " << defaultItem.getName() << endl;
    cout << "Дата оформления: " << defaultItem.getDate() << endl;
    cout << "Цена товара: " << defaultItem.getPrice() << endl;
    cout << "Количество единиц товара: " << defaultItem.getQuantity() << endl;
    cout << "Номер накладной: " << defaultItem.getInvoiceNumber() << endl;

    return 0;
}
                                                                                /* Задание_1.3 */
#include <iostream>
#include <string>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    // Конструктор по умолчанию
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        cout << "Вызван конструктор по умолчанию." << endl;
    }

    // Конструктор класса
    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        cout << "Вызван конструктор с параметрами." << endl;
    }

    // Деструктор
    ~Goods() {
        cout << "Вызван деструктор." << endl;
    }

    // Метод редактирования информации о товаре
    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }

    // Метод вычисления общей стоимости товара
    double calculateTotalCost() const {
        return price * quantity;
    }

    // Методы получения значения полей
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }
};

int main() {
    // Создание экземпляра класса Goods с параметрами
    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    // Редактирование информации о товаре
    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    // Проверка значений полей
    cout << "Наименование товара: " << item.getName() << endl;
    cout << "Дата оформления: " << item.getDate() << endl;
    cout << "Цена товара: " << item.getPrice() << endl;
    cout << "Количество единиц товара: " << item.getQuantity() << endl;
    cout << "Номер накладной: " << item.getInvoiceNumber() << endl;

    // Вычисление общей стоимости товара
    cout << "Общая стоимость товара: " << item.calculateTotalCost() << endl;

    return 0;
}
                                                                                /* Задание_1.4 */
#include <iostream>
#include <string>
#include <chrono>
#include <ctime>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор по умолчанию в " << std::ctime(&currentTime);
    }

    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор с параметрами в " << std::ctime(&currentTime);
    }

    ~Goods() {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор в " << std::ctime(&currentTime);
    }

    // Функции редактирования и получения информации о товаре
    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }
    
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }

    // Функция расчета общей стоимости товара
    double calculateTotalCost() const {
        return price*quantity;
    }
};

int main() {
    cout << "Вход в функцию main()" << endl;

    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    cout << "Наименование товара: " << item.getName() << endl;
    cout << "Дата оформления: " << item.getDate() << endl;
    cout << "Цена товара: " << item.getPrice() << endl;
    cout << "Количество единиц товара: " << item.getQuantity() << endl;
    cout << "Номер накладной: " << item.getInvoiceNumber() << endl;

    cout << "Общая стоимость товара: " << item.calculateTotalCost() << endl;

    cout << "Выход из функции main()" << endl;

    return 0;
}
                                                                                /* Задание_1.5 */
#include <iostream>
#include <string>
#include <chrono>
#include <ctime>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор по умолчанию в " << std::ctime(&currentTime);
    }

    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор с параметрами в " << std::ctime(&currentTime);
    }

    Goods(const Goods &goods) // This is the copy constructor
        : name(goods.name), date(goods.date), price(goods.price), quantity(goods.quantity), invoiceNumber(goods.invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор копирования в " << std::ctime(&currentTime);
    }

    ~Goods() {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор в " << std::ctime(&currentTime);
    }

    // Функции редактирования и получения информации о товаре
    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }
    
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }

    // Функция расчета общей стоимости товара
    double calculateTotalCost() const {
        return price*quantity;
    }
};

int main() {
    cout << "Вход в функцию main()" << endl;

    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    Goods copiedItem = item; // Call to the copy-constructor

    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    cout << "Наименование товара: " << item.getName() << endl;
    cout << "Дата оформления: " << item.getDate() << endl;
    cout << "Цена товара: " << item.getPrice() << endl;
    cout << "Количество единиц товара: " << item.getQuantity() << endl;
    cout << "Номер накладной: " << item.getInvoiceNumber() << endl;

    cout << "Наименование скопированного товара: " << copiedItem.getName() << endl;
    cout << "Дата оформления: " << copiedItem.getDate() << endl;
    cout << "Цена товара: " << copiedItem.getPrice() << endl;
    cout << "Количество единиц товара: " << copiedItem.getQuantity() << endl;
    cout << "Номер накладной: " << copiedItem.getInvoiceNumber() << endl;

    cout << "Общая стоимость товара: " << item.calculateTotalCost() << endl;

    cout << "Выход из функции main()" << endl;

    return 0;
}
                                                                        /* Задание_1.5.1 */
#include <iostream>
#include <string>
#include <chrono>
#include <ctime>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор по умолчанию в " << std::ctime(&currentTime);
    }

    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор с параметрами в " << std::ctime(&currentTime);
    }

    Goods(const Goods &goods) // This is the copy constructor
        : name(goods.name), date(goods.date), price(goods.price), quantity(goods.quantity), invoiceNumber(goods.invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор копирования в " << std::ctime(&currentTime);
    }

    ~Goods() {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор в " << std::ctime(&currentTime);
    }

    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }
    
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }

    double calculateTotalCost() const {
        return price*quantity;
    }

    void displayGoodsInfo() {
        cout << "Наименование товара: " << getName() << endl;
        cout << "Дата оформления: " << getDate() << endl;
        cout << "Цена товара: " << getPrice() << endl;
        cout << "Количество единиц товара: " << getQuantity() << endl;
        cout << "Номер накладной: " << getInvoiceNumber() << endl;
        cout << "Общая стоимость товара: " << calculateTotalCost() << endl;
    }
};

int main() {
    cout << "Вход в функцию main()" << endl;

    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    Goods copiedItem = item; // Call to the copy-constructor
    
    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    cout << "Выход из функции main()" << endl;

    return 0;
}
                                                                        /* Задание_1.5.2 */
#include <iostream>
#include <string>
#include <chrono>
#include <ctime>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор по умолчанию в " << std::ctime(&currentTime);
    }

    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор с параметрами в " << std::ctime(&currentTime);
    }

    Goods(const Goods &goods) // This is the copy constructor
        : name(goods.name), date(goods.date), price(goods.price), quantity(goods.quantity), invoiceNumber(goods.invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор копирования в " << std::ctime(&currentTime);
    }

    ~Goods() {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор в " << std::ctime(&currentTime);
    }

    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }
    
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }

    double calculateTotalCost() const {
        return price*quantity;
    }

    void displayGoodsInfo() {
        cout << "Наименование товара: " << getName() << endl;
        cout << "Дата оформления: " << getDate() << endl;
        cout << "Цена товара: " << getPrice() << endl;
        cout << "Количество единиц товара: " << getQuantity() << endl;
        cout << "Номер накладной: " << getInvoiceNumber() << endl;
        cout << "Общая стоимость товара: " << calculateTotalCost() << endl;
    }
};

Goods tovar(Goods s) {
    return s;
}

int main() {
    cout << "Вход в функцию main()" << endl;

    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    Goods copiedItem = item; // Call to the copy-constructor
    
    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    Goods newGoods = tovar(item);
    newGoods.displayGoodsInfo();

    cout << "Выход из функции main()" << endl;

    return 0;
}
                                                                        /* Задание_1.5.3 */
Если вы измените функцию tovar так, чтобы она принимала Goods по ссылке, это уменьшит количество копий, 
создаваемых при работе вашей программы. В текущей реализации метод вызывает конструктор копирования для 
формирования нового объекта Goods, когда функция вызывается.

Измененная функция могла бы выглядеть вот так:
Goods& tovar(Goods& s) {
    return s;
}

В этом случае функция возвращает ссылку на тот же объект Goods, что и передается ей, вместо того чтобы 
возвращать копию. Таким образом, эта функция больше не вызывает конструктор копирования.

Однако стоит отметить, что в этом случае newGoods в основной функции будет лишь ссылкой на item. 
Это значит, что любые изменения, произведенные с newGoods, отразятся также и на item, и наоборот. 
Точно так же, если item будет удалён, то и ссылка newGoods станет недействительной.

Конфигурация с передачей параметра по ссылке будет полезна, когда вы хотите изменить объект прямо в функции, 
или когда объект слишком большой, и его копирование затратно. В противном случае вполне желательно оставить 
функцию с передачей параметра по значению, чтобы избегать неожиданных взаимодействий объектов в разных частях программы.
                                                                        /* Задание_1.5.4 */
Изменим функцию tovar таким образом, чтобы она возвращала ссылку на объект, а не сам объект:

Goods& tovar(Goods& s) {
    return s;
}

Теперь функция tovar() будет возвращать ссылку на объект Goods, а не копию объекта. Это означает, 
что при использовании этой функции копирование объекта не производится.

Ваш исходный код вызывал копирование объекта при возвращении его из функции tovar(), что можно было 
увидеть по сообщению из конструктора копирования. Когда вы измените функцию tovar(), чтобы она возвращала 
ссылку, конструктор копирования не будет вызван, и соответствующего сообщения не будет.

Это полезно, если вы хотите изменить переданный в функцию объект, и хотите, чтобы эти изменения остались 
после выхода из функции. Это также более эффективно с точки зрения производительности, поскольку не происходит 
копирование всего объекта.

Однако, это также может быть рискованно, если вам нужно работать с оригинальным объектом позже, и вы не 
хотите, чтобы он был изменён. В этом случае лучше использовать копирование.
                                                                        /* Задание_1.6 */
#include <iostream>
#include <string>
#include <chrono>
#include <ctime>

using namespace std;

class Goods {
private:
    string name;
    string date;
    double price;
    int quantity;
    string invoiceNumber;

public:
    Goods() : name("Не указано"), date("Не указано"), price(0.0), quantity(0), invoiceNumber("Не указано")
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор по умолчанию в " << std::ctime(&currentTime);
    }

    Goods(const string& name, const string& date, double price, int quantity, const string& invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор с параметрами в " << std::ctime(&currentTime);
    }

    Goods(const Goods &goods) // This is the copy constructor
        : name(goods.name), date(goods.date), price(goods.price), quantity(goods.quantity), invoiceNumber(goods.invoiceNumber)
    {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор копирования в " << std::ctime(&currentTime);
    }

    ~Goods() {
        auto now = std::chrono::system_clock::now();
        std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор в " << std::ctime(&currentTime);
    }

    Goods& operator=(const Goods& goods) {
        if (&goods == this)
            return *this;
        name = goods.name;
        date = goods.date;
        price = goods.price;
        quantity = goods.quantity;
        invoiceNumber = goods.invoiceNumber;
        return *this;
    }

    void editGoods(const string& newName, const string& newDate, double newPrice, int newQuantity, const string& newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }
    
    string getName() const {
        return name;
    }

    string getDate() const {
        return date;
    }

    double getPrice() const {
        return price;
    }

    int getQuantity() const {
        return quantity;
    }

    string getInvoiceNumber() const {
        return invoiceNumber;
    }

    double calculateTotalCost() const {
        return price*quantity;
    }

    void displayGoodsInfo() {
        cout << "Наименование товара: " << getName() << endl;
        cout << "Дата оформления: " << getDate() << endl;
        cout << "Цена товара: " << getPrice() << endl;
        cout << "Количество единиц товара: " << getQuantity() << endl;
        cout << "Номер накладной: " << getInvoiceNumber() << endl;
        cout << "Общая стоимость товара: " << calculateTotalCost() << endl;
    }
};

Goods tovar(Goods s) {
    return s;
}

int main() {
    cout << "Вход в функцию main()" << endl;

    Goods item("Телевизор", "01.10.2023", 999.99, 1, "12345");

    Goods copiedItem = item; // Call to the copy-constructor
    
    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    item.editGoods("Холодильник", "01.10.2023", 1099.99, 2, "67890");

    item.displayGoodsInfo();
    copiedItem.displayGoodsInfo();

    Goods newGoods = tovar(item);
    newGoods.displayGoodsInfo();

    Goods assignedItem;
    assignedItem = item; // Call to the assignment operator

    assignedItem.displayGoodsInfo();

    cout << "Выход из функции main()" << endl;

    return 0;
}

                                                                ВРОДЕ ТО ЧТО НУЖНО, ОТ И ДО 
#include <iostream>
#include <chrono> // Для измерения времени
using namespace std;

class Goods {
private:
    string name;
    string date;
    float price;
    int quantity;
    int invoiceNumber;

public:
    Goods() {
        auto now = chrono::system_clock::now();
        time_t tt = chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор Goods по умолчанию: " << ctime(&tt) << endl;
    }

    Goods(const string& name, const string& date, float price, int quantity, int invoiceNumber)
        : name(name), date(date), price(price), quantity(quantity), invoiceNumber(invoiceNumber) {
        auto now = chrono::system_clock::now();
        time_t tt = chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор Goods с параметрами: " << ctime(&tt) << endl;
    }

    // Конструктор копирования
    Goods(const Goods& other) {
        name = other.name;
        date = other.date;
        price = other.price;
        quantity = other.quantity;
        invoiceNumber = other.invoiceNumber;
        auto now = chrono::system_clock::now();
        time_t tt = chrono::system_clock::to_time_t(now);
        cout << "Вызван конструктор копирования Goods: " << ctime(&tt) << endl;
    }

    // Оператор присваивания
    Goods& operator=(const Goods& other) {
        if (this == &other)
            return *this;

        name = other.name;
        date = other.date;
        price = other.price;
        quantity = other.quantity;
        invoiceNumber = other.invoiceNumber;
        auto now = chrono::system_clock::now();
        time_t tt = chrono::system_clock::to_time_t(now);
        cout << "Вызвана операция присваивания Goods: " << ctime(&tt) << endl;

        return *this;
    }

    ~Goods() {
        auto now = chrono::system_clock::now();
        time_t tt = chrono::system_clock::to_time_t(now);
        cout << "Вызван деструктор Goods: " << ctime(&tt) << endl;
    }

    void editInfo(const string& newName, const string& newDate, float newPrice, int newQuantity, int newInvoiceNumber) {
        name = newName;
        date = newDate;
        price = newPrice;
        quantity = newQuantity;
        invoiceNumber = newInvoiceNumber;
    }

    float calculateTotalCost() {
        return price * quantity;
    }
};

Goods tovar(Goods s) {
    return s;
}

int main() {
    cout << "Вход в функцию main()" << endl;
    Goods g1;
    Goods g2("Товар 1", "01.10.2023", 10.99, 5, 12345); 

    Goods g3 = g2;
    Goods g4(g3);

    g1.editInfo("Новое имя", "02.10.2023", 15.99, 3, 54321); 

    float totalCost = g1.calculateTotalCost();

    Goods g5 = tovar(g1); 

    g3 = g1; // Здесь срабатывает оператор присваивания

    cout << "Выход из функции main()" << endl;

    return 0;
}